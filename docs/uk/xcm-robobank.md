---
title: Substrate Cumulus Parachain Testsuite для міжланцюжкового обміну повідомленнями 

contributors: [ddulesov, boogerwooger, tubleronchik] 
---


Основною метою цього проекту є спрощення розробки часу виконання парачейну, коли використовуються міжланцюжкові овідомлення. 
Він дозволяє розробляти код часу виконання з інтеграційними тестами з високим ступенем повторюваності та простим використанням.
Він автоматизує побудову, створення попередньо налаштованої конфігурації мережі (тобто 1 реле-ланцюг + 2 парачейни), налаштування каналів передачі повідомлень між парачейнами та запуск тестів повідомлень, відправку повідомлень, використання виклику до часу виконання, все побудовано і складено на Python.

XCM Testsuite використовується для тестування виробничого циклу Robobank - набору палет Substrate, які дозволяють роботам реєструватися на зовнішніх парачейнах, отримувати передоплачені замовлення, виконувати їх та отримувати платежі з використанням зовнішніх токенів. Це дозволяє роботам працювати в мережі Robonomics з усією необхідною інфраструктурою, але в той же час пропонувати свої послуги на будь-якому іншому парачейні.

Приклад відео доступний на [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)

Основні кроки в демо-сценарії:
- запуск реле-ланцюга та двох парачейнів у пакеті з 6 процесами
- налаштування каналів передачі повідомлень XCM між парачейнами
- реєстрація робота в обох парачейнах
- створення замовлення для цього робота в клієнтському парачейні (резервування платежу за виконання замовлення)
- відправка повідомлення XCM на парачейн Robonomics
- створення "дзеркального" запису замовлення на парачейні Robonomics
- робот приймає замовлення на парачейні Robonomics
- відправка повідомлення XCM про прийняття замовлення назад на клієнтський парачейн
- прийняття замовлення на клієнтському парачейні (резервування штрафу за невиконання замовлення до кінцевого терміну)
- робот виконує замовлення на парачейні Robonomics
- відправка повідомлення XCM про завершення замовлення на клієнтський парачейн
- розрахунок всіх платежів (платіж клієнта передається роботу, а також не використаний штраф за невикористання замовлення)
- закриття замовлення1


## Вгору
Цей проект є форком
[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).
Він містить код палеток часу виконання, які тестуються.
Як і в оригінальному вузловому коді парачейнів знаходяться в каталогах "./pallets", "./runtime", "./node".

Відмінності від оригінального "substrate-node-template":
- цей час виконання колатора має модуль обробника HRMP і може обробляти повідомлення від парачейнів-сусідів
- мок-тестовий час виконання готовий для внутрішніх тестів XCM

## Побудова та запуск
Рекомендована (висока) настройка: 
```
Ubuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD
```
[ПРИМІТКА] Перша збірка може зайняти багато часу, до кількох годин на нептимальних машинах.

[ПРИМІТКА] Скрипт працює з ФІКСОВАНИМИ версіями (хешами комітів) Polkadot(Rococo) в реле-ланцюзі та парачейнах.

[ПРИМІТКА] За замовчуванням скрипт перестворює те саме середовище кожного запуску, видаляючи всі попередні стани. Цю поведінку можна змінити в "config.sh", використовуючи параметр "PERSISTENT".


Запустіть скрипт побудови та налаштування.  
```bash
git clone https://github.com/airalab/xcm-robobank-prototype.git
cd xcm-robobank-prototype
./scripts/init.sh
```

Основні дії скрипта "init.sh":
 - читання конфігурації (файл "config.sh" з номером ревізії, початковими ключами та ідентифікаторами вузлів, параметром збереження даних ланцюга тощо)
 - налаштування пакетів ОС, Rust та Python
 - побудова окремих бінарних файлів для реле-ланцюга та для обох парачейнів
    - бінарні файли будуть згенеровані в підкаталозі ./bin. 
 - (необов'язково) видалення всіх попередніх даних ланцюга для всіх ланцюгів
    - вимикається, якщо "PERSISTENT=1" встановлено в "config.sh"
 - працює як окремі процеси (з окремими PID та каналами введення/виведення):
    - валідатори реле-ланцюга (тобто 4 валідатори, які працюють на стабільній ревізії Rococo)
    - колатори для парачейна-100 (тобто один колатор для першого парачейна, який ви розробляєте)
    - колатори для парачейна-200 (тобто один колатор для другого парачейна, який ви розробляєте)
 - друкує всі кінцеві точки, порти на консоль, що дозволяє вивчати будь-який ланцюг за допомогою фронтенд-додатків (експлорер, DApp)
 - продовжує друкувати всі вихідні дані всіх ланцюгів на консоль

[ПОПЕРЕДЖЕННЯ] Після запуску зачекайте, поки мережа запуститься, переконайтеся, що фіналізація блоку розпочалася, і що парачейни зареєстровані. Ці процеси повинні зайняти приблизно 5 хв (50 блоків x 6 сек).

## Перевірка роботи початкової настройки 

Використовуйте стандартний фронтенд Polkdot та згенеровані кінцеві точки "--ws-port" для підключення до кожного вузла.
Відкрийте [додаток Polkadot](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) для моніторингу ланцюгів. 

### Приклад:
Localhost, 4 валідатори реле-ланцюга, один колатор парачейна-100, один колатор парачейна-200:
- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)
- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)
- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)
- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)
- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)
- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)


Якщо все працює, і консенсус розпочато, ми можемо перейти до запуску наших тестових випадків (у новому терміналі).

### Тест передачі повідомлень UMP
```bash
./scripts/init.sh ump
```
Він створює повідомлення `Balance.transfer` в `parachain-100` і передає його на реле-ланцюг.
Коли реле-ланцюг отримує повідомлення, він переказує 15 токенів з рахунку `para 100` на рахунок Чарлі.


### Тест передачі повідомлень HRMP
```bash
./scripts/init.sh ump
```

Він створює повідомлення `Balance.transfer` в `parachain-100` і передає його на `sibling 200`.
Перед цим він надає рахунку `subl 100` 1000 токенів і встановлює комунікаційний канал між паралелізмами.
```bash
./scripts/init.sh hrmp
```
Наступні повідомлення можна надсилати, запустивши підкоманду `hrmpm`. Вона не створює каналу, тому працює швидше.
```bash
./scripts/init.sh hrmpm
```

### Додаткові параметри
```bash
./scripts/init.sh help
```

## Локальна тестова мережа

### Створити настроюваний специфікацію ланцюжка
```
./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json
```

Редагуйте rococo_local.json, замініть параметри балансів та авторитетів на свої.
```json
  "keys": [
    [
      "",
      "",
      {
        "grandpa": "",
        "babe": "",
        "im_online": "",
        "para_validator": "",
        "para_assignment": "",
        "authority_discovery": ""
      }
    ]
```

Адреса Polkadot для //Alice//stash (криптографія sr25519).
```bash
$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash
```

```text
Secret Key URI `//Alice//stash` is account:
Secret seed:      

Public key (hex): 

Account ID:       

SS58 Address:     
```

Ключ сесії Polkadot grandpa для //Alice (криптографія ed25519).
```bash
$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice
```
```text
Secret Key URI `//Alice` is account:
Secret seed:      

Public key (hex): 

Account ID:       

SS58 Address:     
```

Адреса Polkadot для //Alice (криптографія sr25519).
```
$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice
```
```text
Secret Key URI `//Alice` is account:
Secret seed:      

Public key (hex): 

Account ID:       

SS58 Address:     
```

Конвертувати rococo_local.json у формат raw.
```
./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json
```
Щоб використовувати нову специфікацію ланцюжка, замініть файл rococo.json у каталозі ./config/ на цей новий і перезапустіть ланцюжок.
```bash
./scripts/init.sh run
```
Ви можете вільно редагувати код. Вищезазначена команда перебудує проект та оновить вузловий вузол перед запуском.
Cumulus - це передвипускне програмне забезпечення, яке все ще перебуває в активній розробці.
We are using a specific commit of polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15  18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)

Ви можете використовувати більш нові версії програмного забезпечення. Для цього змініть POLKADOT_COMMIT у ./scipt/config.sh
на останній коміт гілки `rococo-v1`, видаліть ./bin/polkadot та запустіть 
```bash
./scripts/init.sh run
```

Оновлення залежностей проекту коллатора 
```bash
cargo update
./scripts/init.sh build
```
Деякі залежності, ймовірно, вимагають нових функцій інструментарію Rust. Цей проект базується на Rust `nightly-2021-01-26`
Оновіть версію інструментарію Rust у ./scripts/config.sh перед збіркою.

## Взламати паралелізм
[Додати зовнішню палету](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - можливо, це повинно бути в розділі "дізнатися більше"?
## Learn More

Зверніться до вихідного [Шаблон вузла розробника Substrate Developer Hub](https://github.com/substrate-developer-hub/substrate-node-template), щоб дізнатися більше про структуру цього проекту, можливості, які він вкладає, та спосіб, яким ці можливості реалізовані. Ви можете дізнатися більше про [Шлях блоку паралелізму](https://polkadot.network/the-path-of-a-parachain-block/) на офіційному блозі Polkadot. [Паритетний семінар Cumulus](https://substrate.dev/cumulus-workshop/#/)